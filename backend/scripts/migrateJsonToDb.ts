#!/usr/bin/env ts-node

import prisma from '../src/db/prisma';
import fs from 'fs';
import path from 'path';

const DEV_USER_ID = 'dev-user-id-12345';

interface JsonBookmark {
  id: string;
  url: string;
  title?: string;
  domain?: string;
  summary?: string;
  contentType?: string;
  status?: string;
  metadata?: Record<string, unknown>;
  tags?: string[];
  embedding?: number[];
  createdAt: string;
  updatedAt: string;
  processedAt?: string;
  embeddedAt?: string;
}

async function migrateBookmarks() {
  const jsonPath = path.join(__dirname, '../../frontend/.data/bookmarks.json');

  console.log('ðŸ”„ Starting bookmark migration from JSON to PostgreSQL...\n');

  // Check if file exists
  if (!fs.existsSync(jsonPath)) {
    console.log('âš ï¸  No bookmarks.json found, skipping migration');
    console.log(`   Looked in: ${jsonPath}\n`);
    return;
  }

  // Read JSON file
  console.log(`ðŸ“– Reading bookmarks from: ${jsonPath}`);
  const fileContent = fs.readFileSync(jsonPath, 'utf-8');
  const data = JSON.parse(fileContent);

  // Handle both nested and flat structures
  const bookmarks: JsonBookmark[] = data.bookmarks || data;
  console.log(`   Found ${bookmarks.length} bookmarks\n`);

  if (bookmarks.length === 0) {
    console.log('âœ“ No bookmarks to migrate\n');
    return;
  }

  // Migrate each bookmark
  let successCount = 0;
  let skipCount = 0;
  let errorCount = 0;

  for (const bookmark of bookmarks) {
    try {
      // Check if bookmark already exists
      const existing = await prisma.bookmark.findUnique({
        where: { id: bookmark.id },
      });

      if (existing) {
        console.log(`â­ï¸  Skipping ${bookmark.id} - already exists`);
        skipCount++;
        continue;
      }

      // Create bookmark in database
      await prisma.bookmark.create({
        data: {
          id: bookmark.id,
          userId: DEV_USER_ID,
          url: bookmark.url,
          title: bookmark.title || '',
          domain: bookmark.domain || '',
          summary: bookmark.summary,
          contentType: bookmark.contentType || 'other',
          status: bookmark.status || 'completed',
          metadata: bookmark.metadata as any || {},
          createdAt: new Date(bookmark.createdAt),
          updatedAt: new Date(bookmark.updatedAt),
          processedAt: bookmark.processedAt ? new Date(bookmark.processedAt) : null,
        },
      });

      // Migrate embeddings if they exist
      if (bookmark.embedding && Array.isArray(bookmark.embedding) && bookmark.embedding.length === 1536) {
        try {
          const embeddingStr = `[${bookmark.embedding.join(',')}]`;
          await prisma.$executeRaw`
            UPDATE bookmarks
            SET embedding = ${embeddingStr}::vector
            WHERE id = ${bookmark.id}
          `;
        } catch (embError) {
          console.warn(`  âš ï¸  Failed to migrate embedding for ${bookmark.id}`);
        }
      }

      // Migrate tags if they exist
      if (bookmark.tags && bookmark.tags.length > 0) {
        for (const tagName of bookmark.tags) {
          try {
            const normalizedName = tagName.toLowerCase().trim();

            // Find or create tag
            let tag = await prisma.tag.findFirst({
              where: { userId: DEV_USER_ID, normalizedName }
            });

            if (!tag) {
              tag = await prisma.tag.create({
                data: {
                  userId: DEV_USER_ID,
                  name: tagName,
                  normalizedName,
                }
              });
            }

            // Link tag to bookmark
            await prisma.bookmarkTag.create({
              data: {
                bookmarkId: bookmark.id,
                tagId: tag.id,
                autoGenerated: true,
              }
            });
          } catch (tagError) {
            console.warn(`  âš ï¸  Failed to migrate tag "${tagName}" for ${bookmark.id}`);
          }
        }
      }

      console.log(`âœ“ Migrated: ${bookmark.title || bookmark.url.substring(0, 50)}${bookmark.tags ? ` (${bookmark.tags.length} tags)` : ''}`);
      successCount++;
    } catch (error) {
      console.error(`âœ— Failed to migrate ${bookmark.id}:`, error instanceof Error ? error.message : String(error));
      errorCount++;
    }
  }

  // Print summary
  console.log('\nðŸ“Š Migration Summary:');
  console.log(`   Total bookmarks: ${bookmarks.length}`);
  console.log(`   âœ“ Successfully migrated: ${successCount}`);
  console.log(`   â­ï¸  Skipped (already exist): ${skipCount}`);
  console.log(`   âœ— Errors: ${errorCount}`);

  if (successCount > 0) {
    console.log(`\nâœ… Migration complete! ${successCount} bookmarks added to PostgreSQL\n`);
  } else if (skipCount === bookmarks.length) {
    console.log('\nâœ… All bookmarks already exist in database\n');
  } else {
    console.log('\nâš ï¸  Migration completed with errors\n');
  }
}

// Run migration
migrateBookmarks()
  .catch((error) => {
    console.error('\nâŒ Migration failed:', error);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
