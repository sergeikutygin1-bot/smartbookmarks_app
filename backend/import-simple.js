const { PrismaClient } = require('@prisma/client');
const fs = require('fs');

const prisma = new PrismaClient();

async function importBookmarks() {
  console.log('ðŸ”„ Starting bookmark import...\n');

  const data = JSON.parse(fs.readFileSync('/app/bookmarks.json', 'utf-8'));
  console.log(`ðŸ“Š Found ${data.bookmarks.length} bookmarks to import\n`);

  // Get or create user
  let user = await prisma.user.findFirst();
  if (!user) {
    user = await prisma.user.create({
      data: { email: 'user@smartbookmarks.local', passwordHash: 'placeholder' },
    });
  }
  console.log(`âœ“ Using user: ${user.email}\n`);

  let imported = 0;
  for (const bm of data.bookmarks) {
    try {
      const existing = await prisma.bookmark.findFirst({
        where: { url: bm.url, userId: user.id },
      });
      if (existing) continue;

      // Insert bookmark with raw SQL for embedding
      const result = await prisma.$queryRawUnsafe(`
        INSERT INTO bookmarks (
          id, user_id, url, title, domain, summary, content_type, status,
          embedding, created_at, updated_at, processed_at
        ) VALUES (
          gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7,
          $8::vector, $9, $10, $11
        ) RETURNING id
      `,
        user.id,
        bm.url,
        bm.title,
        bm.domain,
        bm.summary || '',
        bm.contentType || 'article',
        'completed',
        `[${bm.embedding.join(',')}]`,
        new Date(bm.createdAt),
        new Date(bm.updatedAt),
        bm.processedAt ? new Date(bm.processedAt) : null
      );

      const bookmarkId = result[0].id;

      // Add tags
      if (bm.tags && bm.tags.length > 0) {
        for (const tagName of bm.tags) {
          const norm = tagName.toLowerCase().trim();

          let tag = await prisma.tag.findFirst({
            where: { userId: user.id, normalizedName: norm },
          });

          if (!tag) {
            tag = await prisma.tag.create({
              data: { userId: user.id, name: tagName, normalizedName: norm },
            });
          }

          await prisma.bookmarkTag.create({
            data: { bookmarkId, tagId: tag.id, autoGenerated: true },
          }).catch(() => {}); // Ignore duplicates
        }
      }

      console.log(`âœ“ ${bm.title.substring(0, 60)}...`);
      imported++;
    } catch (e) {
      console.error(`âœ— ${bm.title.substring(0, 60)}...`, e.message);
    }
  }

  console.log(`\nâœ“ Imported ${imported}/${data.bookmarks.length} bookmarks`);
  await prisma.$disconnect();
}

importBookmarks().catch(console.error);
