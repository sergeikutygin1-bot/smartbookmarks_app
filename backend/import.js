const { PrismaClient } = require('@prisma/client');
const fs = require('fs');

const prisma = new PrismaClient();

async function importBookmarks() {
  console.log('üîÑ Starting bookmark import...\n');

  const data = JSON.parse(fs.readFileSync('/app/bookmarks.json', 'utf-8'));
  console.log(`üìä Found ${data.bookmarks.length} bookmarks to import\n`);

  let user = await prisma.user.findFirst();
  if (!user) {
    console.log('üë§ Creating default user...');
    user = await prisma.user.create({
      data: {
        email: 'user@smartbookmarks.local',
        passwordHash: 'placeholder',
      },
    });
    console.log(`‚úì Created user: ${user.email}\n`);
  } else {
    console.log(`‚úì Using existing user: ${user.email}\n`);
  }

  let imported = 0;
  let skipped = 0;

  for (const bookmark of data.bookmarks) {
    try {
      const existing = await prisma.bookmark.findFirst({
        where: { url: bookmark.url, userId: user.id },
      });

      if (existing) {
        console.log(`‚è≠  Skipped: ${bookmark.title.substring(0, 50)}...`);
        skipped++;
        continue;
      }

      // Convert embedding array to pgvector format: [1,2,3,...]
      const embeddingStr = `[${bookmark.embedding.join(',')}]`;

      const createdBookmark = await prisma.bookmark.create({
        data: {
          userId: user.id,
          url: bookmark.url,
          title: bookmark.title,
          domain: bookmark.domain,
          summary: bookmark.summary,
          contentType: bookmark.contentType,
          status: 'completed',
          embedding: embeddingStr,
          createdAt: new Date(bookmark.createdAt),
          updatedAt: new Date(bookmark.updatedAt),
          processedAt: bookmark.processedAt ? new Date(bookmark.processedAt) : null,
        },
      });

      if (bookmark.tags && bookmark.tags.length > 0) {
        for (const tagName of bookmark.tags) {
          const normalizedName = tagName.toLowerCase().trim();

          let tag = await prisma.tag.findFirst({
            where: { userId: user.id, normalizedName },
          });

          if (!tag) {
            tag = await prisma.tag.create({
              data: {
                userId: user.id,
                name: tagName,
                normalizedName,
              },
            });
          }

          await prisma.bookmarkTag.create({
            data: {
              bookmarkId: createdBookmark.id,
              tagId: tag.id,
              autoGenerated: true,
            },
          });
        }
      }

      console.log(`‚úì Imported: ${bookmark.title.substring(0, 50)}...`);
      imported++;
    } catch (error) {
      console.error(`‚úó Failed: ${bookmark.title.substring(0, 50)}...`, error.message);
    }
  }

  console.log(`\nüìä Import Summary:`);
  console.log(`   ‚úì Imported: ${imported}`);
  console.log(`   ‚è≠  Skipped: ${skipped}`);
  console.log(`   üìö Total: ${data.bookmarks.length}`);

  await prisma.$disconnect();
}

importBookmarks().catch(console.error);
